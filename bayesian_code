library(tidyverse)
library(lrgs)
library(fastDummies)
library(ggplot2)
library(GGally)

db <- read_csv(choose.files())
db <- db %>% mutate(Species = as.factor(Species))

db <- dummy_cols(db, remove_first_dummy = TRUE,remove_selected_columns = TRUE)

#Verificando váriaveis
boxplot(db$Weight)

#retirando observacao 0
db <- db %>% filter(Weight != 0)

boxplot(db$Length1)
boxplot(db$Length2)
boxplot(db$Length3)
boxplot(db$Height)
boxplot(db$Width)

#verificando correlação entre preditoras
ggpairs(db[,1:6])

#decidimos manter apenas um length

db <- db %>% select(-Length2,-Length3)

ggpairs(db[,1:4])

#dada as claras correlções entre entre as preditoras, adicionamos interação para controlar.

db <- db %>% mutate("Length1:Height" = Length1*Height, "Length1:Width" = Length1*Width, "Height:Width" = Height*Width, "Length1:Height:Width" = Length1*Height*Width)

#tranformando Y para ln(Y)

db <- db %>% mutate(Weight = log(Weight))

bayesian_model <- Gibbs.regression(as.matrix(db[,2:14]), db$Weight, NULL, 10000, trace='bsmt', fix='xy') ##GIBBS

post_chains_1 <- Gibbs.post2dataframe(bayesian_model)[,1:15]

#distribuicões dos B e Sigma a posteriori
#B1

for (i in 1:14){
  g <- ggplot(post_chains_1, aes(x = post_chains_1[,i]))+
    geom_density(fill = 4, color = 4)+
    geom_vline(aes(xintercept = mean(post_chains_1[,i]), color = "Média"), show.legend = TRUE)+
    labs(title = paste("Distribuição a posteriori de B",i),x = paste("B",i), y = "densidade")+
    scale_colour_discrete(name = "Legenda")
    
  print(g)
}

ggplot(post_chains_1,aes(x = Sigma11))+
  geom_histogram(fill = 4, color = 4)+
  geom_vline(aes(xintercept = mean(Sigma11), color = "Média"),show.legend = TRUE)+
  labs(title = "Distribuição a posteriori de Sigma",x = "Sigma11", y = "densidade")+
  scale_colour_discrete(name = "Legenda")


#Intervalos de credibilidade de 95%

cred_intervals <- data.frame(colnames(post_chains_1), rep(0,15), rep(0,15))
colnames(cred_intervals) <- c("Parâmetro","2.5%","97.5%")

for (i in 1:15){
  low <- as.numeric(quantile(post_chains_1[,i],0.025))
  high <- as.numeric(quantile(post_chains_1[,i],0.975))
  cred_intervals[i,2] <- low
  cred_intervals[i,3] <- high
}
# Temos como não significativo algumas dummies de espécie, porém optamos por manter a categórica

#cálculo da distribuição de r^2 a posteriori
# ...
# ...

# análise de resíduos pelos betas médios

post_means_B <- rep(0,14)
for (i in 1:14){
  post_means_B[i] <- mean(post_chains_1[,i])
}

X <- mutate(db, intercepto = 1) %>% select(intercepto, 2:14)

residuals <- as.matrix(db[,1]) - as.matrix(X) %*% matrix(post_means_B, nrow = 14)

ggplot(residuals,aes(x = residuals[,1]))+
  geom_histogram()

ggplot(residuals,aes(sample = residuals[,1]))+
  geom_qq()+
  geom_qq_line()


# distribuição preditiva de alguns betas (pode ser uma validação cruzada se quisermos)
# ...
# ..
